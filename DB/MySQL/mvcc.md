# Multi-Version Concurrency Control

MySQL 트랜잭션 스토리지 엔진은 주로 MVCC와 레코드 락을 함께 사용한다.

> MVCC : Multi-Version Concurrency Control, 다중 버전 동시성 제어  
> 여러 트랜잭션이 동시에 데이터베이스에 접근할 때 데이터의 일관성과 격리성을 보장하는 기술.
> 이는 `Repeatable Read` 와 `Read Commited` 에서만 동작한다. (트랜잭션 레벨이 다르기 때문)

- 각 트랜잭션마다 데이터의 변경 내역을 별도의 버전으로 관리하는 방식
- 각 버전은 트랜잭션의 시작 시간과 종료 시간을 기록 .
- 트랜잭션이 변경하는 데이터에 대해서만 새로운 버전을 생성.
- 다른 트랜잭션이 같은 데이터를 동시에 변경할 때 충돌을 최소화하고, 동시성을 높일 수 있다.

MVCC의 동작 방식은 크게 두 가지가 있다.

- Read View 생성

  - 트랜잭션이 시작될 때 Read View를 생성합니다.
  - Read View는 트랜잭션이 시작한 시간을 기준으로 해당 시점에서의 데이터 상태를 반영.
  - 따라서 트랜잭션은 자신이 시작한 시점의 데이터를 읽는 것을 보장.

- Write Version

  - 트랜잭션이 데이터를 수정할 때, 새로운 버전을 생성하고 해당 버전에 변경 내역을 저장.
  - 이를 통해 다른 트랜잭션이 같은 데이터를 수정할 때 원래 버전에 영향을 주지 않고 동시에 작업 가눙.

- MVCC 자체는 여러 DB에서 사용하지만 그 표준이 정의되어 있지는 않다.

레코드 락과 같이 쓰기 작업에 필요한 레코드만 락을 걸며 동시에 읽기를 허용할 수 있다.

- MVCC는 데이터 스냅샷을 사용한다.
- 이를 통해서 트랜잭션과 관계 없이 데이터를 일관되게 볼 수 있다.

InnoDB의 경우

- InnoDB는 트랜잭션 마다 데이터를 처음 읽는 시점에 ID를 할당한다.
- 레코드 수정이 발생하면 `Undo` 레코드를 `Undo 로그`에 기록하고 트랜잭션의 롤백 포인터로 지정한다.

다른 세션이 클러스터 키 인덱스 레코드를 읽는다면?

- InnoDB는 레코드의 트랜잭션 ID와 해당 세션의 읽기 뷰를 비교.
- 변경한 트랜잭션이 커밋되지 않은 경우 (레코드의 현재 상태 X)
- 세션이 볼 수 있는 트랜잭션 ID에 도달할 때 까지 `Undo` 레코드 추적, 적용

트랜잭션 레코드는 어떻게 삭제되는가?

- 레코드의 `info flags` 에서 `deleted` 비트를 설정하여 삭제 된다.
- `Undo 로그` 에서는 `remove delete mark` 로 추적

`Undo 로그와 Redo 로그`

- 이는 서버 충돌 복구 프로세스의 일부이며 트랜잭션
- 내부적으로 `Undo 로그` 쓰기 작업은 `Redo 로그` 로 처리된다.
- 이 로그 들의 크기는 높은 동시성 트랜잭션에 영향을 준다.

이러한 추가 레코드 보관을 통한 로그 관리의 단점은?

- 읽기 쿼리는 대부분 락을 획득하지 못한다. → 최대한 데이터를 빨리 읽어 기준에 맞는 행만 선택
- 스토리지 엔진은 각 행에 더 많은 데이터를 저장해야 한다.
- 스토리지 엔진은 각 행을 검사할 때 더 많은 작업과 추가 관리 작업을 처리해야 한다.

MVCC의 장점은?

- 동시성 향상: 여러 트랜잭션이 동시에 데이터에 접근할 수 있습니다. 이로 인해 동시성이 향상되며, DB의 성능을 향상시킬 수 있다.
- 높은 격리 수준: MVCC는 트랜잭션이 수정하는 데이터에 대해서만 새로운 버전을 생성하므로 다른 트랜잭션과 격리 수준이 높아진다.
- 따라서 트랜잭션 간의 충돌이 최소화되며, 데이터의 일관성이 유지됩니다.
