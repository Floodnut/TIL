# 영속성 컨텍스트

### EntityManager

-   엔티티 매니저 팩토리는 매 요청마다 엔티티 매니저를 생성한다.
-   엔티티 매니저는 내부적으로 DB 커넥션을 만들어 DB를 이용한다.

### 영속성 컨텍스트

-   영속성 컨텍스트는 논리적인 개념이다.
-   엔티티를 영구적으로 저장하고 객체로 이용할 수 있게 하는 환경.
-   이를 이용해서 엔티티를 영속성 컨텍스트에 영속적으로 저장한다.
-   J2SE 환경에서 각 엔티티 매니저는 개별적인 영속성 컨텍스트를 가진다.
-   J2EE, 스프링과 같은 컨테이너 환경에서는 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 가진다.

### 엔티티의 생명주기

-   비영속 - `new` , `transient`
    -   영속성 컨텍스트와 전혀 관계 없는 새로운 상태
        -   최초 객체를 생성한 상태
        -   값을 `set()` 하였지만 영속성 컨텍스트에 아직 저장하지 않음.
-   영속 - `managed`
    -   영속성 컨텍스트에 관리되는 상태
    -   `persist()` 로 저장된 상태
-   준영속 - `detached`
    -   영속성 컨텍스트에 저장되어있다가 분리된 상태
-   삭제 - `removed`
    -   영속성 컨텍스트에서 삭제된 상태

### 영속성 컨텍스트가 가지는 이점

-   1차 캐시
    -   DB 접근 이전에 영속성 컨텍스트를 먼저 조회.
    -   DB 조회 결과를 영속성 컨텍스트에 반영
    -   그러나, 트랜잭션이 종료되면 캐시가 사라짐.
-   영속 엔티티의 동일성 보장
    -   1차 캐시에서 동일한 객체에 대해 동일하다고 판단.
-   트랜잭션을 지원하는 쓰기 지연 가능
    
    -   `persist()` 시점에서 **기본적으로는 쿼리를 DB로 보내지 않음.**
        -   쓰기 지연 SQL 저장소에 쿼리를 생성한다.
    -   트랜잭션을 커밋`commit()` 하는 시점에 쿼리를 보낸다.
    
    ```
    <property name="hibernate.jdbc.batch_size" value="5"/>
    ```
    
-   변경 감지 (Dirty Check)
    -   값을 변경할 경우 `persist()` 를 호출하지 않더라도 변경(`update`)된다.
        -   트랜잭션의 `commit()` 시점에 `flush()` 된다.
        -   이때 변경된 내용을 1차 캐시에서 스냅샷으로 비교한다.
        -   변경된 내용이 있다면 쓰기 지연 SQL 저장소에 `update` 쿼리를 생성한다.
        -   이후 DB로 flush, commit 한다.
-   엔티티 삭제
    -   `remove()` 를 통해 `commit()` 시점에 `delete` 쿼리를 발생시킨다.

### Flush

-   영속성 컨텍스트의 변경 내용을 DB에 반영하는 것.
    -   트랜잭션 단위가 기준.
-   플러시 후에도 1차 캐시는 유지.
    -   즉, 영속성 컨텍스트를 지우지 않음
-   플러시 발생 시
    -   변경 감지
    -   수정된 엔티티를 쓰기지연 SQL 저장소에 등록
    -   **쓰기지연 SQL 저장소의 쿼리를 DB에 전달**
-   플러시 호출
    -   `em.flush()` 직접 호출
    -   트랜잭션 커밋 시점에 자동 호출
    -   JPQL 쿼리 실행 시점에 자동 호출
-   플러시 모드
    -   `em.setFlushMode(FlushModeType.AUTO)` (기본값)
    -   커밋이나 쿼리 실행 시점에 플러시
    -   `em.setFlushMode(FlushModeType.COMMIT)`
    -   커밋 시점에만 플러시

### 준영속 상태

-   영속 상태의 엔티티가 영속성 컨텍스트에서 분리됨
-   `em.detach(entity)`, `em.clear()`, `em.close()`